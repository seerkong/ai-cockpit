# 系统级工作流

## 指导原则

1. **规范是真实来源：** 所有工作必须在 plan.xml 中追踪
2. **技术栈是慎重选择的：** 对技术栈的更改必须在实现前记录在 tech-stack.md 中
3. **测试驱动开发：** 在实现功能前编写单元测试
4. **高代码覆盖率：** 所有模块的代码覆盖率目标为 >80%
5. **用户体验优先：** 每个决策都应优先考虑用户体验
6. **非交互式和 CI 感知：** 优先使用非交互式命令。对监视模式工具使用 `CI=true`

## 任务工作流

所有任务遵循严格的生命周期：

### 标准任务工作流

1. **选择任务：** 从 plan.xml 按顺序选择下一个可用任务

2. **标记进行中：** 开始工作前，将任务状态从 `TODO` 改为 `IN_PROGRESS`

3. **编写失败测试（红色阶段）：**
   - 为功能或 Bug 修复创建测试文件
   - 编写一个或多个单元测试，清楚定义预期行为和验收标准
   - **关键：** 运行测试并确认按预期失败。这是 TDD 的"红色"阶段。在有失败测试前不要继续

4. **实现通过测试（绿色阶段）：**
   - 编写使失败测试通过所需的最少代码
   - 再次运行测试套件确认所有测试通过。这是"绿色"阶段

5. **重构（可选但推荐）：**
   - 在通过测试的保护下，重构实现代码和测试代码
   - 提高清晰度、消除重复、增强性能，同时不改变外部行为
   - 重新运行测试确保仍然通过

6. **验证覆盖率：** 使用项目工具运行覆盖率报告
   ```bash
   bun test --coverage
   ```
   目标：新代码覆盖率 >80%

7. **记录偏差：** 如果实现与技术栈不同：
   - **停止**实现
   - 用新设计更新 `tech-stack.md`
   - 添加带日期的注释解释更改
   - 恢复实现

8. **提交代码更改（根据提交模式）：**

   **如果是 auto 模式：**
   - 暂存所有与任务相关的代码更改
   - 使用规范的提交消息格式：`feat(<track_id>): <任务描述>`
   - 附加 Git Notes 记录变更详情：
     ```bash
     git add .
     git commit -m "feat(<track_id>): complete task T1.2 - <任务名称>"
     git notes add -m "Task: T1.2
     Changes: <变更摘要>
     Files: <文件列表>
     AC: <验收标准>"
     ```

   **如果是 manual 模式：**
   - 通知用户任务代码已完成
   - 提示用户自行提交

9. **更新任务状态：**
   - 将任务状态从 `IN_PROGRESS` 更新为 `DONE`
   - 在任务元素中记录 commit SHA（如果有）
   - 更新 `<acceptance_criteria>` 中各标准的 `checked` 属性

10. **提交任务更新（auto 模式）：**
    - 暂存修改的 plan.xml
    - 提交更改，消息如 `codument(task): Mark task 'Create user model' as complete`


### 更正进行中工作流
当有如下情况：
- 当前有进行中的tracks
- 用户提出的补充需求，属于当前进行中的某个track范围

需要执行下述工作流：
1. **找到track：** 找到补充需求所属的进行中的track
2. **更正plan.xml：** 在所属的plan.xml，合适的位置，按照`plan-xml-spec.md`的规范，新增内容，初始化状态


### 阶段完成验证协议

**触发器：** 完成某个阶段的最后一个任务后立即执行
**执行条件：** 仅当该 `<phase>` 下存在 `<confirm protocol="yield-human-confirm" .../>` 或 `<confirm protocol="yield-ai-confirm" .../>` 且 when 包含 `after`（见 `codument/std/protocols.md`）

1. **宣布协议开始：** 通知用户阶段已完成，验证和检查点协议开始

2. **确保阶段变更的测试覆盖率：**
   - 确定阶段范围：找到上一个阶段检查点的 Git commit SHA
   - 列出变更文件：`git diff --name-only <previous_checkpoint_sha> HEAD`
   - 验证并创建测试：对每个代码文件验证对应测试文件存在

3. **执行自动化测试：**
   - 宣布将执行的确切 shell 命令
   - 执行命令
   - 如果失败，通知用户并开始调试。最多尝试修复两次
   - 如果仍失败，停止并请求用户指导

4. **提议手动验证计划：**
   - 分析 product.md 和 plan.xml 确定用户目标
   - 生成分步验证计划，包括命令和预期结果

5. **等待用户反馈：**
   - 请求确认："这是否符合预期？请用 yes 确认或提供反馈。"（使用 **Protocol: ask-single-question-free**）
   - 等待用户响应

6. **创建检查点提交：**
   - 暂存所有更改
   - 提交，消息如 `codument(checkpoint): Checkpoint end of Phase X`

7. **更新任务并记录检查点 SHA：**
   - 在 plan.xml 中阶段元素添加 checkpoint 属性

8. **提交任务更新：**
   - 提交更改，消息如 `codument(phase): Mark phase 'P1' as complete`

9. **宣布完成：** 通知用户阶段已完成

### 质量门控

在将任何任务标记为完成前，验证：

- [ ] 所有测试通过
- [ ] 代码覆盖率满足要求（>80%）
- [ ] 代码遵循项目代码风格指南
- [ ] 所有公共函数/方法有文档
- [ ] 强制类型安全
- [ ] 无代码检查或静态分析错误
- [ ] 文档已更新（如需要）
- [ ] 未引入安全漏洞

## 测试要求

### 单元测试
- 每个模块必须有对应测试
- 使用适当的测试设置/拆卸机制
- 模拟外部依赖
- 测试成功和失败情况

### 集成测试
- 测试完整命令流程
- 验证文件系统操作
- 测试错误处理

## 提交指南

### 消息格式
```
<类型>(<范围>): <描述>

[可选正文]

[可选页脚]
```

### 类型
- `feat`: 新功能
- `fix`: Bug 修复
- `docs`: 仅文档
- `style`: 格式化，缺少分号等
- `refactor`: 既不修复 Bug 也不添加功能的代码更改
- `test`: 添加缺失测试
- `chore`: 维护任务

### 示例
```bash
git commit -m "feat(cli): Add list command with specs option"
git commit -m "fix(validate): Correct scenario parsing for GIVEN/WHEN/THEN"
git commit -m "test(utils): Add tests for parseTaskDetails function"
```

## 完成定义

任务在以下情况下完成：

1. 所有代码按规范实现
2. 单元测试编写并通过
3. 代码覆盖率满足项目要求
4. 文档完成（如适用）
5. 代码通过所有配置的代码检查
6. 实现说明添加到 plan.xml
7. 更改用正确消息提交
8. 任务状态更新为 DONE

## 持续改进

- 每周审查工作流
- 根据痛点更新
- 记录经验教训
- 优化用户满意度
- 保持简单和可维护

## 其他项目级workflow
请阅读 `codument/workflows/` 目录下的更多文件，了解更多的本项目专属工作流